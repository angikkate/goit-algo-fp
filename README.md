# goit-algo-fp
# Завдання 1. Однозв’язний список

У програмі реалізовано:
Функцію реверсування однозв’язного списку (зміна посилань між вузлами).
Алгоритм сортування злиттям для однозв’язного списку.
Функцію об’єднання двох відсортованих списків в один відсортований.

Результат:
Початковий список:
3 -> 1 -> 4 -> 2 -> 5 -> None
Реверсований:
5 -> 2 -> 4 -> 1 -> 3 -> None
Відсортований:
1 -> 2 -> 3 -> 4 -> 5 -> None
Об’єднання двох відсортованих:
1 -> 2 -> 3 -> 4 -> 5 -> 6 -> None

# Завдання 2. Рекурсія. Фрактал "Дерево Піфагора"

Програма будує фрактал дерево Піфагора за допомогою рекурсії.
Використовується модуль turtle для візуалізації.

Результат:
Відкривається вікно з деревом, розгалуження повторюються рекурсивно на задану глибину.

# Завдання 3. Алгоритм Дейкстри

Алгоритм знаходить найкоротші шляхи у зваженому графі.
Використовується бінарна купа (heapq) для оптимізації вибору вершин.
Виводяться відстані від стартової вершини до кожної вершини графа.

Результат:
Найкоротші відстані від вершини A:
1. Вершина A — відстань 0
2. Вершина B — відстань 3
3. Вершина C — відстань 2
4. Вершина D — відстань 8
5. Вершина E — відстань 10
6. Вершина Z — відстань 13

# Завдання 4. Візуалізація бінарної купи

Програма будує бінарну купу (heap) з масиву чисел.
Використовується клас Node для вузлів дерева.
Візуалізація через networkx і matplotlib показує структуру дерева.

Результат:
Для масиву [4, 10, 3, 5, 1] будується дерево, де корінь – найбільше число (max-heap), дочірні вузли – менші, візуалізовано графічно.

# Завдання 5. Візуалізація обходу бінарного дерева

Реалізовано обходи дерева:
DFS (глибина) – через стек.
BFS (ширина) – через чергу.
Кожен вузол при відвідуванні отримує унікальний колір від темного до світлого (RGB), що показує порядок обходу.

Результат:
Візуалізація змінює кольори вузлів у дереві за порядком відвідування.
DFS: вузли відвідані по глибинах.
BFS: вузли відвідані по рівнях.

# Завдання 6. Жадібні алгоритми та динамічне програмування

Жадібний алгоритм: обирає страви за максимальним співвідношенням калорій/вартість, не перевищуючи бюджет.
Динамічне програмування: обчислює оптимальний набір страв для максимізації калорій при заданому бюджеті.

Результат:
Жадібний алгоритм:
Страви: ['cola', 'potato', 'pepsi', 'hot-dog']
Калорії: 870
Вартість: 80

Динамічне програмування:
Страви: ['pizza', 'pepsi', 'cola', 'potato']
Калорії: 970
Вартість: 100

# Завдання 7. Метод Монте-Карло

Симулює кидки двох кубиків багато разів.
Обчислює суму чисел та підраховує частоту появи кожної суми (2–12).
Визначає ймовірність кожної суми і порівнює з аналітичними розрахунками.

Результат:
Сума : Кількість : Ймовірність
2 : 2698 : 0.0270
3 : 5560 : 0.0556
4 : 8295 : 0.0829
5 : 11280 : 0.1128
6 : 13932 : 0.1393
7 : 16667 : 0.1667
8 : 13835 : 0.1384
9 : 11026 : 0.1103
10 : 8459 : 0.0846
11 : 5498 : 0.0550
12 : 2750 : 0.0275